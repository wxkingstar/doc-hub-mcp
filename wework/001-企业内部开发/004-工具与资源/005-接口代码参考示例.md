---
title: "接口代码参考示例"
doc_id: 10520
category_id: 90308
source_url: https://developer.work.weixin.qq.com/document/path/10520
---
[TOC]

## 示例代码
以下代码仅是示范用的```伪代码```，所使用的接口需要用户自行实现。

### 通讯录接口
企业微信开放了两种权限，通讯录的读取以及编辑权限，下面以新增一个部门为例（其他接口与之类似）：

**第一步：**获取通讯录应用的access_token
```
 public function getAccessToken($corpid,$secret) { 
 //TODO: access_token 应该全局存储与更新，以下代码以写入到文件中做示例 
    //TODO: 每个应用的access_token应独立存储，此处用secret作为区分应用的标识
 $path = "../cache/$secret.php";
 $data = json_decode(get_php_file($path));
 
 if($data->expire_time < time()) { 
 $url = "https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$corpid&corpsecret=$secret"; 
 $res = json_decode(http_get($url)["content"]);

 $access_token = $res->access_token;
 
 if($access_token) {
 $data->expire_time = time() + 7000;
 $data->access_token = $access_token; 
 set_php_file($path, json_encode($data));
 }
 } else {
 $access_token = $data->access_token;
 }
 return $access_token; 
 }
```
**第二步：**封装数据包发送到企业微信后台
```
  $info = $array("name" => "新增部门名称", 
             "parentid" => 1,
             "order" => 10,
             "id" => 12);

    //TODO：此处传入你的企业corpid以及通讯录应用的secret信息
    $txl_access_token = getAccessToken("corpid","txl_secret");    
    print(http_post("https://qyapi.weixin.qq.com/cgi-bin/department/create?access_token=$txl_access_token",$info));
```
### 应用管理
企业微信为企业提供了动态控制应用上下线以及菜单项的能力，下面以动态更新应用配置信息为例：
**第一步：**获取自定义应用的access_token
参见通讯录接口的access_token获取方式

**第二步：**封装数据包发送到企业微信后台
```
$info = $array("agentid" => "agentid", //TODO:配置需要更新的应用ID
            "report_location_flag" => 0,
            "name" => "HR助手",
            "description" => "企业好助手",
            "redirect_domain" => "open.work.weixin.qq.com",
            "isreportenter" => 0,
            "home_url" => "http://www.qq.com"
           );

//TODO:此处传入你的企业的corpid以及对应应用的secret信息
$app_access_token = getAccessToken("corpid","app_secret");
print(http_post("https://qyapi.weixin.qq.com/cgi-bin/agent/set?access_token=$app_access_token",$info));
```
### 消息服务
消息服务可以为企业成员与企业后台之间建立一个双向通信的能力，如果企业需要主动给成员推送消息，步骤如下：
**第一步：**获取自定义应用的access_token
参见通讯录接口的access_token获取方式

**第二步：**封装数据包发送到企业微信后台
```
$msg = array(
       'touser'=>'UserID', 
       'toparty'=>'1', 
       'msgtype'=>'news',
       'agentid'=>1000007,
       'news'=>array(
         "articles"=> array(0=>array(
           "title"=>"中秋节礼品领取",
           "description"=>"今年中秋节公司有豪礼相送",
           "url"=>"http://qq.com",   "picurl"=>"http://res.mail.qq.com/node/ww/wwopenmng/images/independent/doc/test_pic_msg1.png"
         ))
       )
     );
       
$app_access_token = getAccessToken("corpid","app_secret");
print(http_post("https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$app_access_token",$msg));

```

**接收用户消息处理逻辑示例：**
```
function receiveMsgFromQyWx(){     
    //TODO:配置接收消息的应用相关信息
    $token = $config->Token;
    $encodingAesKey = $config->EncodingAESKey;  
    $corpId = $appConfigs->CorpId;
    
    $sReqMsgSig = $_GET["msg_signature"];  
    $sReqTimeStamp = $_GET["timestamp"];  
    $sReqNonce = $_GET["nonce"];  
    $sReqData = file_get_contents("php://input");    

    $sMsg = ""; // 解析之后的明文
    $wxcpt = new MsgCrypt($token,$encodingAesKey,$corpId);
    $errCode = $wxcpt->DecryptMsg($sReqMsgSig, $sReqTimeStamp, $sReqNonce, $sReqData, $sMsg);

    if ($errCode == 0) {
      // 解密成功，sMsg即为xml格式的明文
      $xml = new DOMDocument();
      $xml->loadXML($sMsg);
      //取出发送消息的UserID
      $FromUserName = $xml->getElementsByTagName('FromUserName')->item(0)->nodeValue; 
      //取出发送的消息内容体
      $content = $xml->getElementsByTagName('Content')->item(0)->nodeValue; 
      //TODO ... 业务逻辑          
    } else {
      print("ERR: " . $errCode . "\n\n");      
    }
  }
```
**企业被动回复用户消息示例：**
```
  function replyMsgToUser(){
    // 需要发送的明文消息 
    // TODO：根据用户提交过来的操作封装此数据包
    $sRespData = "<xml>
            <ToUserName><
- ![CDATA[mycreate]]></ToUserName>
            <FromUserName><
- ![CDATA[wx5823bf96d3bd56c7]]></FromUserName>
            <CreateTime>1348831860</CreateTime>
            <MsgType><
- ![CDATA[text]]></MsgType>
            <Content><
- ![CDATA[this is a test]]></Content>
           </xml>";

    $sEncryptMsg = ""; //xml格式的密文
    $wxcpt = new MsgCrypt($token,$encodingAesKey,$corpId);
    $errCode = $wxcpt->EncryptMsg($sRespData, $sReqTimeStamp, $sReqNonce, $sEncryptMsg);

    if ($errCode == 0) {      
      // 加密成功，企业需要将加密之后的sEncryptMsg返回
      
      // TODO:向企业微信的后台回复消息
    } else {
      print("ERR: " . $errCode . "\n\n");
      // exit(-1);
    }
  }
```
### 网页开发
如果你需要在应用的网页里面使用企业微信提供的强大jsapi能力，那么你可以这样在你的网页中使用：
**第一步：**获取自定义应用的access_token
参见通讯录接口的access_token获取方式

**第二步：**获取自定义应用的jsapi_ticket
```
function getJsApiTicket($corpid,$secret) { 
 // jsapi_ticket 应该全局存储与更新，以下代码以写入到文件中做示例
 $path = "../cache/jsapi_ticket.php";
 $data = json_decode(get_php_file($path));
 $app_access_token = getAccessToken($corpid,$secret); 

 if($data->expire_time < time()){ 
 $accessToken = $this->accessToken->getAccessToken(); 
 $url = "https://qyapi.weixin.qq.com/cgi-bin/get_jsapi_ticket?access_token=$app_access_token"; 
 $res = json_decode(http_get($url)["content"]);
 $ticket = $res->ticket;

 if ($ticket) {
 $data->expire_time = time() + 7000;
 $data->jsapi_ticket = $ticket; 
 set_php_file($path, json_encode($data));
 }
 } else {
 $ticket = $data->jsapi_ticket;
 }

 return $ticket;
 }
```
**第三步：**获取自定义应用的签名对象
```
 function getSignPackage() {
   //TODO:填写你需要生成签名的企业ID以及应用密钥
 $jsapiTicket = getJsApiTicket("corpid","app_secret");

 // 注意 URL 一定要动态获取，不能 hardcode.
 $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' || $_SERVER['SERVER_PORT'] == 443) ? "https://" : "http://";
 $url = "$protocol$_SERVER[HTTP_HOST]$_SERVER[REQUEST_URI]";

 $timestamp = time();
 $nonceStr = createNonceStr();

 //这里参数的顺序要按照 key 值 ASCII 码升序排序
 $string = "jsapi_ticket=$jsapiTicket&noncestr=$nonceStr&timestamp=$timestamp&url=$url";
 $signature = sha1($string);

 $signPackage = array(
 "appId" => $this->appId,
 "nonceStr" => $nonceStr,
 "timestamp" => $timestamp,
 "url" => $url,
 "signature" => $signature,
 "rawString" => $string
 );
 return $signPackage; 
}
```
**第四步：**在页面上完成引用配置
```
<?php
 require_once "../lib/jssdk.php"; 

 //第一步: 生成JSAPI签名
 $jssdk = getSignPackage();
 $signPackage = $jssdk->GetSignPackage();
?>

<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <title>JSAPI 签名输出测试</title> 
</head>
<body>
</body>

<!-- 第二步: 引用JSAPI 的脚本文件 -->
<script src="http://work.weixin.qq.com/wework_admin/jweixin"></script>
<script>
 /*
 * 第三步: 配置jsapi的权限 
 * 注意：所有的JS接口只能可信域名下调用 
 */
 wx.config({
 debug: true,
 appId: '<?php echo $signPackage["appId"];?>', //此处的appId等同于企业的CorpID
 timestamp: '<?php echo $signPackage["timestamp"];?>',
 nonceStr: '<?php echo $signPackage["nonceStr"];?>',
 signature: '<?php echo $signPackage["signature"];?>',
 jsApiList: [
 // 所有要调用的 API 都要加到这个列表中
 ]
 });
 wx.ready(function () {
 //TODO： 执行和jsapi相关的初始化操作
 });
</script>
</html>
```

### 代码示例下载
[点击下载PHP版本的示例](http://open.work.weixin.qq.com/wwopen/downloadfile/OpenApiSample.zip)。

## 开源demo
我们也在Github开源社区提供了更完整的示例代码, 目前已有：[php版](https://github.com/sbzhu/weworkapi_php)，[python版](https://github.com/sbzhu/weworkapi_python)。当然，你可以使用其他你熟悉的语言来开发，也欢迎开发者们在开源社区分享你的代码。

##意见与反馈
如果你在开发过程中遇到问题，建议你先阅读接口相关文档或者使用<a href="http://work.weixin.qq.com/api/devtools/devtool.php" target="_blank">开发者调试工具</a>对需要验证的接口进行调试定位，如果不能解决你的问题，可[联系我们](#10521)进行反馈。
