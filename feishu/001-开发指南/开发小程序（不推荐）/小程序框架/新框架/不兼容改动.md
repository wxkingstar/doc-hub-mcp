---
title: "不兼容改动"
source_url: https://open.feishu.cn/document/client-docs/gadget/framework/new-framework/breaking-changes
---
最后更新于 2023-08-25

# 不兼容改动

当你在使用小程序新框架时，业务代码可能会因为新框架的不兼容改动（breaking changes）而出现异常。如果你在开启新框架，并进行小程序的预览测试时发现异常，可以参考本文提供的不兼容改动说明排查解决。

## selectComponent

### 背景信息

selectComponent 是自定义组件的方法。在基于 uni-app 开发的小程序中，你可能为了方便地在 Vue 实例中使用 `this.selectComponent` 方式调用自定义组件的 selectComponent 方法，而将自定义组件实例上的 `.selectComponent` 方法赋到了 Vue 实例上。示例代码如下：

```javascript 
var _default = _vue.default.extend({
  created: function created() {
	// ...
    if (this.$scope) {
      this.selectComponent = this.$scope.selectComponent;
    }
  },
  // ...
});
``` 

如上述代码中 `this` 是 Vue 实例，而 `this.$scope` 是和这个 Vue 实例关联的、用 Component 方法注册后被创建的自定义组件实例。  

该配置方式是一个明显的 `this` 误用的方式，因为自定义组件实例的 `.selectComponent` 中的逻辑，是按照 `this` 是自定义组件实例进行编写的。如果此时将其赋给 Vue 实例，将导致其被调用时 `this` 指向 Vue 实例，进而导致方法访问 `this` 上的某些属性时出现属性不存在的情况，产生报错。报错示例信息如下：

```shell 
TypeError: Cannot read property 'element' of undefined
``` 

- 旧框架中不会报以上错误的原因：旧框架的 selectComponent 只访问 `this.__webviewId__` 和 `this.__nodeId__`，这些属性在 Vue 实例上存在（Vue 实例上的这些属性，是从自定义组件实例上获取并进行赋值的），所以不会出现问题。   

- 新框架会报以上错误的原因：新框架的 selectComponent 的参数和返回值没有变化，但是内部实现改变了。selectComponent 会访问 this 实例上的其他属性，而这些属性在 Vue 实例上是不存在的，所以会报错。

### 兼容方式

如果你必须把 selectComponent 挂在 Vue 实例上，则建议使用以下封装方式，让 `this` 正确指向自定义组件实例。

```javascript 
var _default = _vue.default.extend({
  created: function created() {
	// ...
     if (this.$scope) {
        this.selectComponent = function () {
            // this 是 uni-app 封装的 Vue 实例，而 this.$scope 是和 uni-app 封装的 Vue 实例关联的自定义组件实例
            // 而自定义组件实例上，this === this.$scope.$vm
            this.$scope.selectComponent.apply(this.$scope, arguments);
        }
    }
  },
  // ...
});
``` 
或者，你也可以改为直接调用 this.$scope.selectComponent。示例代码如下：

```javascript 
this.$scope.selectComponent('#user-avatar', (component) => {
	console.log('获取到 user-avatar 自定义组件', component);
});
``` 

## dataset

### 背景信息

TTML 上的 dataset 属性写作 data-instanceId 的驼峰式写法时，该节点的 dataset 会被转成 `currentTarget.dataset.instanceId` 而不是 `currentTarget.dataset.instanceid`。示例代码如下：

- TTML 中的写法。

```html
<view data-instanceId="12345" bindtap="onTap"></view>
```

- Page() 函数中的代码。

```javascript
Page({
    onTap(e){
        // 旧框架下是 .instanceid
        console.log(e.target.dataset.instanceid)
        console.log(e.currentTarget.dataset.instanceid)
        // 新框架下是 .instanceId
        console.log(e.target.dataset.instanceId)
        console.log(e.currentTarget.dataset.instanceId)
    }
})
```

### 兼容方式

建议你在使用 `data-` 属性时，维持良好的写作规范。
新旧框架均兼容以下两种写作方式。  

- 方式一：在 TTML 中，使用 `instance-id` 这样的短线连接的形式，然后在事件回调函数中以 `dataset.instanceId` 的方式读取。

- 方式二：在 TTML 中，直接以全部小写无短线连接的写作形式（例如，`instanceid`），然后在事件回调函数中以 `dataset.instanceid` 的方式读取。

## observer

### 背景信息

observer 是自定义组件属性变化时触发的回调函数。示例代码如下：

```javascript
Component({
    properties: {
        name: {
            type: String,
            value: 'anonymous',
            observer: function (newValue, oldValue) {
                console.log('name changed', newValue, oldValue);
            }
        }
    },
    attached() {
        console.log('component attached');
    }
})
```

其中，组件的 name 属性和页面的 name 数据在 TTML 模板上声明了绑定关系，因此页面的 name 数据的值会赋给 name 属性。

```html
<user-card name="{{name}}"></user-card>
```

因为 name 数据的初始值 `kate` 和组件的 name 属性的初始值 `anonymous` 不同，所以会在使用页面数据进行首次渲染时，触发一次 observer，而 onLoad 生命周期触发 next event loop（因为 setTimeout 第二个参数传入 0）后， setData 给 name 数据赋值的 `robin` 又和 `kate` 不同，所以会再次触发一次 observer。

```javascript
Page({
    data: {
        name: 'kate'
    },
    onLoad() {
        setTimeout(() => {
            this.setData({
                name: 'robin'
            });
        }, 0);
    }
})
```

- 在旧框架中，只有第一次 observer 是在 attached 前触发的，后续 observer 的触发都在 attached 之后。例如，在上述代码中，旧框架会输出如下日志。

```shell
name changed kate anonymous
attached
name changed robin kate
```

- 在新框架下会有多次 observer 在 attached 前触发。例如，在上述代码中，新框架会输出如下日志。

```shell
name changed kate anonymous
name changed robin kate
attached
```

observer 回调函数并不是一定在 attached 回调函数之前执行。attached 是自定义组件插入到页面 DOM 节点树时触发的生命周期，如果有一次 setData 触发 observer 是在自定义组件已经渲染完时才触发的，则它依然会在 attached 之后执行。如果在上述代码的基础上增加一个 2000ms 后的 setData，示例代码如下：

```javascript
Page({
    data: {
        name: 'kate'
    },
    onLoad() {
        setTimeout(() => {
            this.setData({
                name: 'robin'
            });
        }, 0);
        setTimeout(() => {
            this.setData({
                name: 'celine'
            });
        }, 2000);        
    }
})
```

则在新框架中会输出如下日志：

```shell
name changed kate anonymous
name changed robin kate
attached
name changed celine robin
```

observer 提前于 attached 执行时，可能因 observer 的逻辑中缺少 attached 中设置的一些变量值，而导致报错或不执行。例如：

```javascript
Component({
    properties: {
        name: {
            type: String,
            value: 'anonymous',
            observer: function (newValue, oldValue) {
                if (this._inited) {
                    this.updateName(newValue);
                }
            }
        }
    },
    methods: {
        updateName() {
        }
    },
    attached() {
        this._inited = true;
    }
})
```

在上述示例场景中，虽然旧框架会错过第一次 observer 里的 updateName，但由于组件首次渲染时被赋值的一般是一些无效的默认值（例如：`''`），因此即使错过，对于实际业务表现一般也不会产生影响。

但在新框架中，会出现多次有效值在赋值时，因触发 observer 里的 updateName 而错过的情况，最终影响实际业务表现。

### 兼容方式

你应该把 attached 和 observer 当做时序顺序，且没有关联的两个独立回调函数。

- observer 是自定义组件属性被赋值时，才触发的回调函数。
- attached 是自定义组件插入到页面 DOM 节点树时，才触发的回调函数。

此时，如果 observer 的实际逻辑执行依赖 attached 设置的变量，就应该在 attached 中对 observer 的逻辑进行补偿执行。例如：

```javascript
Component({
    properties: {
        name: {
            type: String,
            value: 'anonymous',
            observer: function (newValue, oldValue) {
                if (this._inited) {
                    this._nameToUpdate = undefined;
                    this.updateName(newValue);
                } else {
                    // 如果因为 this._inited 不为 true 而不能 update 就把值保存起来
                    this._nameToUpdate = newValue;
                }
            }
        }
    },
    methods: {
        updateName() {
        }
    },
    attached() {
        this._inited = true;
        // 如果有需要 update 的 name 就进行补偿更新
        if (typeof this._nameToUpdate === 'string') {
            this.updateName(this._nameToUpdate);
        }
    }
})
```

在 uni-app 中，应该在调用 watch 方法监听组件属性或 props 变化时，传入 `{ immediate: true }`，表示当监听建立时，立刻执行一次 watch 注册的回调函数。例如：

```javascript
export default defineComponent({
    name: 'container',
    // ...
    setup(props) {
        watch(() => props.create, (v) => {
            if (v === 'true') {
                // ... 更新逻辑
            }
        }, { immediate: true });
    }
})
```

如果不使用 watch 方法，而是用 watch 配置来声明对组件属性的监听，则需要在配置中增加 `{ immediate: true }`。例如：

```javascript
export default Vue.extends({
    props: {
        unionId: String,
    },
    watch: {
        unionId: {
            handler() {
                // ...
            },
            immediate: true
        }
    }
})
```

## updateManager

在飞书客户端版本低于 v6.8 的情况下使用新框架，会存在小概率错误触发 `updateManager.onUpdateReady` 的事件，你需要根据实际场景决定是否关闭此能力，或者调整触发频率。

## 自定义组件作为 slot 插入
一般情况下，该改动场景不需要兼容，因为该场景中的不兼容改动一般不会引起异常。本章节仅作为不兼容的变更进行介绍。

自定义组件可以在自己的 TTML 中声明 slot。

```html
<view class="title"></view>
<view class="content">
    <slot></slot>
</view>
```

自定义组件的直接子节点，会以插入到 slot 节点的身份，插入到 TTML 中 slot 声明的位置。

```html
<user-card>
    <view class="wrapper">
        <view>卡片内容</view>
    </view>
</user-card>

<view class="title"></view>
<view class="content">

<view class="wrapper">
        <view>卡片内容</view>
    </view>
</view>
```

其中，插入到 slot 的节点可以是一个自定义组件。

```html
<user-card>
    <card-content></card-content>
</user-card>
```

如果 slot 使用 `tt:if` 控制存在与否，则当 showSlot 从 `true` 变为 `false` 时，插入到 slot 的组件的 detached 会触发；当 showSlot 从 `false` 变为 `true` 时，插入到 slot 的组件的 attached 会触发。

```html
<view class="title"></view>
<view class="content">
    <slot tt:if="{{showSlot}}"></slot>
</view>
```

```javascript
// card-content
const set = new Set();
Component({
    attached() {
        if (set.has(this)) {
            console.log('attahced, already exist')
        } else {
            console.log('attahced, not exist before')
            set.add(this);
        }
    }
    detached() {
        console.log('detached')
    }
})
```

假设 user-card 的 showSlot 的初始值为 `true`，然后在 attached 中先置为 `false`，再设置为 `true`，即将插入到 slot 的节点先移除再插入。此时，在旧框架中认为创建和销毁的只是 slot 节点，而 slot 节点是一个自定义组件 TTML 里，对外部插入到 slot 节点的引用。

```javascript
// user-card
Component({
    data: {
        showSlot: true
    },
    attached() {
        setTimeout(() => {
            this.setData({
                showSlot: false
            });
            setTimeout(() => {
                this.setData({
                    showSlot: true
                });
            }, 100);
        }, 100);
    }
    detached() {
        console.log('detached')
    }
})
```

因此，在旧框架下 Component 实例会复用之前的实例，在上述的例子中会输出如下日志。

```shell
attahced, not exist before
detached
attahced, already exist
```

在新框架下每次都会创建新的 Component 实例，在上述的例子中会输出如下日志。

```shell 
attahced, not exist before
detached
attahced, not exist before
``` 

如果 `tt:if` 控制的不是 slot 节点，而是插入到 slot 的节点，则如下代码所示。

```html
<user-card>
    <card-content tt:if="{{showSlot}}"></card-content>
</user-card>
```

```javascript
Page({
    data: {
        showSlot: true
    },
    onLoad() {
        setTimeout(() => {
            this.setData({
                showSlot: false
            });
            setTimeout(() => {
                this.setData({
                    showSlot: true
                });
            }, 100);
        }, 100);
    }
});
```

此时，在旧框架的设计里这是在销毁节点本身，在新框架里也同样如此。上述的例子中会输出如下日志。
```shell 
attahced, not exist before
detached
attahced, not exist before
```
